<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一周</title>
    <link href="/2024/07/10/1/"/>
    <url>/2024/07/10/1/</url>
    
    <content type="html"><![CDATA[<h2 id="极客大挑战2019-PHP1"><a href="#极客大挑战2019-PHP1" class="headerlink" title="极客大挑战2019 PHP1"></a>极客大挑战2019 PHP1</h2><h4 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h4><p>常见的网站源码备份文件后缀：</p><ul><li>tar</li><li>tar.gz</li><li>zip</li><li>rar</li></ul><p>常见的网站源码备份文件名：</p><ul><li>web</li><li>website</li><li>backup</li><li>back</li><li>www</li><li>wwwroot</li><li>temp</li></ul><p>根据上述备份文件名及后缀，通过排列组合，找到隐藏的备份文件（也可通过dirsearch工具扫描）</p><p>通过分析代码知，只需绕过__wakeup，即可顺利解出。</p><p>（因为成员（属性）是private，所以要在类名和成员名前加<code>%00</code>，这个url编码是空的意思。因为生产序列化时不会把这个<code>空</code>也输出）</p><p>（也可以直接用序列化后的url编码。这里要注意，php的<code>urlencode()</code>是会自动把<code>空</code>编码成%00，而Python的<code>parse.quote()</code>不会）</p><p><img src="/2024/07/10/1/Users\liu\Desktop\图片\1.flag.png" alt="1.flag"></p><h4 id="绕过-wakeup"><a href="#绕过-wakeup" class="headerlink" title="绕过_wakeup()"></a>绕过_wakeup()</h4><p>绕过_wakeup方法：<strong>当成员属性数目大于实际数目时可绕过wakeup方法</strong></p><h2 id="XYCTF2024-ezhttp"><a href="#XYCTF2024-ezhttp" class="headerlink" title="XYCTF2024 ezhttp"></a>XYCTF2024 ezhttp</h2><p>打开可看到<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134628896.png" alt="image-20240402134628896"></p><p>尝试弱口令登录，<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134709490.png" alt="image-20240402134709490"></p><p>没什么信息，看源码<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134730257.png" alt="image-20240402134730257"></p><p>尝试查看robots.txt<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134818927.png" alt="image-20240402134818927"></p><p>打开禁用文本<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134845287.png" alt="image-20240402134845287"></p><p>拿到账户密码是，登录<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134925323.png" alt="image-20240402134925323"></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134946806.png" alt="image-20240402134946806"></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402134953672.png" alt="image-20240402134953672"></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402135006706.png" alt="image-20240402135006706"></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402135012550.png" alt="image-20240402135012550"></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240402135024875.png" alt="image-20240402135024875"></p><h4 id="伪造来源IP"><a href="#伪造来源IP" class="headerlink" title="伪造来源IP"></a>伪造来源IP</h4><p><strong>总结：简单的http协议，但在伪造ip地址时，发现不允许通过X-Forwarded-For伪造，故可改用client-ip伪造</strong>（参考：<a href="https://blog.csdn.net/huazhongkejidaxuezpp/article/details/50343805">构造HTTP请求Header实现“伪造来源IP”(重在原理)_head伪装ip-CSDN博客</a>）</p><h2 id="攻防世界-Web-php-include"><a href="#攻防世界-Web-php-include" class="headerlink" title="攻防世界 Web_php_include"></a>攻防世界 Web_php_include</h2><p>打开环境</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240415230725357.png" alt="image-20240415230725357"></p><h4 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h4><p><a href="https://blog.csdn.net/yuanxu8877/article/details/127432129">文件包含漏洞总结都在这里了_file&#x3D;1.txt文件包含漏洞-CSDN博客</a></p><h4 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h4><p><a href="https://blog.csdn.net/cosmoslin/article/details/120695429">PHP伪协议详解-CSDN博客</a></p><p>[<a href="https://www.cnblogs.com/-mo-/p/11736445.html">WEB安全]PHP伪协议总结 - 肖洋肖恩、 - 博客园 (cnblogs.com)</a></p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240415231042895.png" alt="image-20240415231042895"></p><p>使用data:&#x2F;&#x2F;伪协议，传入page&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php echo $_SERVER['DOCUMENT_ROOT'];?>得到目录路径</p><h5 id="SERVER-‘DOCUMENT-ROOT’"><a href="#SERVER-‘DOCUMENT-ROOT’" class="headerlink" title="_SERVER[‘DOCUMENT_ROOT’]"></a>_SERVER[‘DOCUMENT_ROOT’]</h5><blockquote><p><code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 是 PHP 中的一个超全局数组，用于获取当前运行脚本所在的文档根目录（Web 服务器的根目录）的路径。</p><p>在绝大多数情况下，<code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 返回的是服务器上的绝对路径，指向 Web 服务器的根目录，即网站的根目录。例如，如果你的网站域名为 <code>example.com</code>，那么 <code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 可能返回的是类似于 <code>/var/www/html/example.com/</code> 或者 <code>/home/user/public_html/</code> 这样的路径。</p><p>通过输出 <code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code>，你可以得知当前 PHP 脚本所在的网站根目录路径。这在构建动态路径或者包含文件时特别有用。</p></blockquote><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240415232534140.png" alt="image-20240415232534140"></p><p>传入page&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php print_r(scandir('/var/www'));?></p><p>获取当前目录文件</p><h5 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h5><blockquote><ul><li><p><code>print_r(scandir(/var/www));</code> 调用了 <code>scandir()</code> 函数来获取 <code>/var/www</code> 目录中的文件和目录列表，并使用 <code>print_r()</code> 函数将结果以可读的形式打印出来。</p></li><li><p><code>scandir()</code> 是 PHP 中的一个函数，用于获取指定目录中的文件和目录列表。它返回一个数组，其中包含目录中的条目的名称。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">scandir</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$directory</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$sorting_order</span> = SCANDIR_SORT_ASCENDING, ?resource <span class="hljs-variable">$context</span> = <span class="hljs-literal">null</span>): <span class="hljs-keyword">array</span>|<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><ul><li><code>$directory</code>：要扫描的目录路径。</li><li><code>$sorting_order</code>：可选参数，用于指定排序顺序。可以是 <code>SCANDIR_SORT_ASCENDING</code>（按字母升序）或 <code>SCANDIR_SORT_DESCENDING</code>（按字母降序）。默认是升序。</li><li><code>$context</code>：可选参数，用于指定上下文。在大多数情况下，可以忽略这个参数。</li></ul><p>该函数返回一个包含目录中的条目的数组，如果失败则返回 <code>false</code>。</p></li></ul></blockquote><h5 id="print-r"><a href="#print-r" class="headerlink" title="print_r()"></a>print_r()</h5><blockquote><ul><li><p><code>print_r()</code> 函数是 PHP 中用于打印变量的函数之一。它以人类可读的形式输出变量的值，通常用于调试目的。<code>print_r()</code> 函数可以输出数组、对象和普通变量等 PHP 数据类型的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$expression</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$return</span> = <span class="hljs-literal">false</span>)<br>  <br></code></pre></td></tr></table></figure></li></ul></blockquote><p>传入&lt;?php $a_code &#x3D; file_get_contents(‘fl4gisisish3r3.php’);</p><p>echo htmlspecialchars($a_code); ?&gt;</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240415232651169.png" alt="image-20240415232651169"></p><h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents"></a>file_get_contents</h5><blockquote><p><code>file_get_contents</code> 是一个 PHP 函数，用于读取文件的内容并将其作为字符串返回。它是 PHP 中用于文件操作的常见函数之一。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$filename</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$use_include_path</span> = <span class="hljs-literal">false</span>, resource <span class="hljs-variable">$context</span> = <span class="hljs-literal">null</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$offset</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$maxlen</span> = <span class="hljs-literal">null</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><ul><li><code>$filename</code>：要读取的文件的路径。</li><li><code>$use_include_path</code>：可选参数，如果设置为 <code>true</code>，则在 include_path 中查找文件。默认为 <code>false</code>。</li><li><code>$context</code>：可选参数，用于指定一个上下文资源，例如通过 <code>stream_context_create()</code> 创建的上下文资源。</li><li><code>$offset</code>：可选参数，指定从文件的哪个位置开始读取，默认为 0，即从文件开头读取。</li><li><code>$maxlen</code>：可选参数，指定最大读取的字节数。如果为 <code>null</code>，则读取整个文件。默认为 <code>null</code>。</li></ul><p><code>file_get_contents</code> 函数会尝试读取指定路径的文件，并将其内容作为字符串返回。如果读取失败，它会返回 <code>false</code>。</p></blockquote><h5 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a>htmlspecialchars</h5><blockquote><p><code>htmlspecialchars</code> 是一个 PHP 函数，用于将字符串中的特殊字符转换为 HTML 实体，以防止跨站脚本攻击（XSS）等安全问题。它将字符串中的特殊字符转换为相应的 HTML 实体，这样浏览器就不会将它们解释为 HTML 标记或 JavaScript 代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">htmlspecialchars</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$string</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$flags</span> = ENT_COMPAT | ENT_HTML401, <span class="hljs-keyword">string</span>|<span class="hljs-literal">null</span> <span class="hljs-variable">$encoding</span> = <span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">&quot;default_charset&quot;</span>), <span class="hljs-keyword">bool</span> <span class="hljs-variable">$double_encode</span> = <span class="hljs-literal">true</span>): <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><ul><li><code>$string</code>：要转换的字符串。</li><li><code>$flags</code>：可选参数，指定转换的规则和标准。默认为 <code>ENT_COMPAT | ENT_HTML401</code>，即将双引号转换为 <code>&quot;</code>，但不转换单引号。你也可以使用 <code>ENT_QUOTES</code> 来转换所有引号，或者使用 <code>ENT_NOQUOTES</code> 来不转换引号。</li><li><code>$encoding</code>：可选参数，指定目标字符集。默认为 <code>ini_get(&quot;default_charset&quot;)</code>，即 PHP 的默认字符集。</li><li><code>$double_encode</code>：可选参数，指定是否对已存在的 HTML 实体进行二次转换。默认为 <code>true</code>，即对已存在的 HTML 实体进行转换。</li></ul></blockquote><h2 id="buuctf-极客大挑战-2019-Buyflag"><a href="#buuctf-极客大挑战-2019-Buyflag" class="headerlink" title="buuctf-[极客大挑战 2019]Buyflag"></a>buuctf-[极客大挑战 2019]Buyflag</h2><p>打开环境，浏览内容，根据题目提示，<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231520017.png" alt="image-20240416231520017"></p><p>打开payflag，查看源码，<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231603653.png" alt="image-20240416231603653"></p><p>发现底部有一段代码，是对传入的password进行判断</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231654692.png" alt="image-20240416231654692"></p><p>再根据页面提示，需要传入参数，抓包尝试</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231823795.png" alt="image-20240416231823795"></p><p>发现有个cookie，改一下试试<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231804348.png" alt="image-20240416231804348"></p><p>发现我已变为student，下面传入密码<img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416231904516.png" alt="image-20240416231904516"></p><p>代码要求不能为数字，且需要等于404</p><h3 id="弱等于绕过"><a href="#弱等于绕过" class="headerlink" title="弱等于绕过"></a>弱等于绕过</h3><p>涉及弱等于的绕过<a href="https://blog.csdn.net/qq_47804678/article/details/128814377">php比较绕过（强比较“&#x3D;&#x3D;&#x3D;”&#x2F;弱比较“&#x3D;&#x3D;“）_php强等于绕过-CSDN博客</a></p><h3 id="is-numeric-函数绕过"><a href="#is-numeric-函数绕过" class="headerlink" title="is_numeric()函数绕过"></a>is_numeric()函数绕过</h3><p>也可利用is_numeric（）函数绕过</p><blockquote><p>is_numeric() 函数用于检测变量是否为数字或数字字符串。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-built_in">bool</span> <span class="hljs-built_in">is_numeric</span> ( mixed $<span class="hljs-keyword">var</span> )<br></code></pre></td></tr></table></figure><p>如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回 1，即 TRUE。</p><p>is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。</p></blockquote><p>密码传入成功后，尝试传入money</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416233318305.png" alt="image-20240416233318305"></p><p>发现too long,尝试科学计数法，拿到flag</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416233358647.png" alt="image-20240416233358647"></p><h3 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h3><p>此题也可用数组绕过</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240416233431613.png" alt="image-20240416233431613"></p><h2 id="ACTF2020新生赛-Exec1"><a href="#ACTF2020新生赛-Exec1" class="headerlink" title="ACTF2020新生赛 Exec1"></a>ACTF2020新生赛 Exec1</h2><p>打开环境，尝试ping 127.0.0.1</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417164458889.png" alt="image-20240417164458889"></p><p>有回显，尝试127.0.0.1 &amp;&amp; ls</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417164754588.png" alt="image-20240417164754588"></p><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>确定为命令执行漏洞 <a href="https://blog.csdn.net/qq_63844103/article/details/126953630">【web安全】——命令执行漏洞（RCE）详解-CSDN博客</a></p><blockquote><p>常见管道符</p><blockquote><p>管道符主要用于多重命令处理，前面命令的打印结果作为后面命令的输入。简单点说就是，就像工厂的流水线一样，进行完一道工序后，继续传送给下一道工序处理…</p></blockquote><h4 id><a href="#" class="headerlink" title="|"></a>|</h4><p>前面的输出，作为后面的输入，前面后面出错，语句都会出错</p><h4 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h4><p>如果前面的命令错误则执行后面的语句，否则不执行。</p><h4 id="-2"><a href="#-2" class="headerlink" title="&amp;"></a>&amp;</h4><p>无论真假，前后命令均执行。将&amp;后的命令置于后台执行</p><h4 id="-3"><a href="#-3" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>如果前面的命令正确则执行后面的语句，否则不执行。</p><h4 id="-4"><a href="#-4" class="headerlink" title=";"></a>;</h4><p>linux下的，和&amp;相同。</p></blockquote><p>所以直接逐层查找flag文件，最终得127.0.0.1 &#x2F; ls ..&#x2F;..&#x2F;..&#x2F;</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417165946018.png" alt="image-20240417165946018"></p><p>直接 127.0.0.1 | cat ..&#x2F;..&#x2F;..&#x2F;flag</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417170025123.png" alt="image-20240417170025123"></p><p>也可直接列出根目录（\）下的内容,111 | ls \</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417170407588.png" alt="image-20240417170407588"></p><h2 id="buuctf-【GXYCTF2019】Ping-Ping-Ping"><a href="#buuctf-【GXYCTF2019】Ping-Ping-Ping" class="headerlink" title="buuctf-【GXYCTF2019】Ping Ping Ping"></a>buuctf-【GXYCTF2019】Ping Ping Ping</h2><p>【BUUCTF】<a href="https://blog.csdn.net/vanarrow/article/details/108295481">GXYCTF2019] Ping Ping Ping 总结笔记 Writeup-CSDN博客</a></p><h2 id="buuctf-【ACTF2020】BackupFile"><a href="#buuctf-【ACTF2020】BackupFile" class="headerlink" title="buuctf-【ACTF2020】BackupFile"></a>buuctf-【ACTF2020】BackupFile</h2><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417174609626.png" alt="image-20240417174609626"></p><h5 id="备份文件-1"><a href="#备份文件-1" class="headerlink" title="备份文件"></a>备份文件</h5><p>根据题目提示，本题考察备份文件，可用disearch扫描</p><p>根据扫描下来的结果，打开&#x2F;index.php.bak文件，下载后用记事本打开</p><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417184111993.png" alt="image-20240417184111993"></p><p>发现是一段简单的php比较，只需get传入key&#x3D;123即可</p><h5 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h5><blockquote><p>本题涉及弱类型比较，详细可参照<a href="https://blog.csdn.net/qq_47804678/article/details/128814377">https://blog.csdn.net/qq_47804678/article/details/128814377</a></p></blockquote><p><img src="/2024/07/10/1/Users\liu\AppData\Roaming\Typora\typora-user-images\image-20240417184250974.png" alt="image-20240417184250974"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git 学习</title>
    <link href="/2024/07/10/git%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/07/10/git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git创建仓库"><a href="#git创建仓库" class="headerlink" title="git创建仓库"></a>git创建仓库</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化git仓库  </p><h2 id="添加文件到git仓库"><a href="#添加文件到git仓库" class="headerlink" title="添加文件到git仓库"></a>添加文件到git仓库</h2><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git commit -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>创建新的目录，是”make directory”的缩写</p><blockquote><p>mkdir [OPTION]… DIRECTORY…</p></blockquote><p>这里的<code>[OPTION]</code>是可选的命令选项，<code>DIRECTORY</code>是您想要创建的目录的名称。</p><p>以下是<code>mkdir</code>命令的一些常用选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>设置创建的目录的文件模式（权限）。</td></tr><tr><td><code>-p</code></td><td>创建必要的父目录，如果这些目录不存在的话。</td></tr><tr><td><code>-v</code></td><td>在每次创建新目录时显示消息。</td></tr></tbody></table><p>eg:</p><blockquote><p>mkdir newdir</p></blockquote><p>这个命令会在当前工作目录下创建一个名为<code>newdir</code>的新目录</p><blockquote><p>mkdir -p dir1&#x2F;dir2&#x2F;dir3</p></blockquote><p>这个命令会创建一个目录结构，即<code>dir1</code>目录下有一个<code>dir2</code>目录，<code>dir2</code>目录下又有一个<code>dir3</code>目录</p><blockquote><p>mkdir -m 700 private_dir</p></blockquote><p>这个命令会创建一个名为<code>private_dir</code>的新目录，并设置其权限为700。</p><blockquote><p>mkdir dir1 dir2 dir3</p></blockquote><p>这个命令会在当前工作目录下创建三个新的目录，分别名为<code>dir1</code>、<code>dir2</code>和<code>dir3</code>。</p><blockquote><p>mkdir -v newdir</p></blockquote><p>这个命令会创建一个名为<code>newdir</code>的新目录，并显示一条消息来确认目录已经被创建。</p><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p><code>pwd</code>是<code>Print Working Directory</code>的缩写，其功能是显示当前所在工作目录的全路径。主要用在当不确定当前所在位置时，通过<code>pwd</code>来查看当前目录的绝对路径。</p><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><strong>git add</strong> 命令可将该文件的修改添加到暂存区。</p><p>通过运行 <strong>git add</strong> 命令，你可以告诉 Git 哪些文件的修改应该包含在下一次提交（commit）中。</p><p>添加一个或多个文件到暂存区：</p><blockquote><p>git add [file1] [file2] …</p></blockquote><p>添加指定目录到暂存区，包括子目录：</p><blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="language-bash"> [<span class="hljs-built_in">dir</span>]</span><br></code></pre></td></tr></table></figure></blockquote><p>添加当前目录下的所有文件到暂存区：</p><blockquote><p>git add .</p></blockquote><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit 命令将暂存区内容添加到本地仓库中。</p><p>提交暂存区到本地仓库中:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> commit -m<span class="hljs-meta"> [message]</span><br></code></pre></td></tr></table></figure><p>[message] 可以是一些备注信息。</p><p>提交暂存区的指定文件到仓库区：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ git commit <span class="hljs-comment">[file1]</span> <span class="hljs-comment">[file2]</span> ... -m <span class="hljs-comment">[message]</span><br></code></pre></td></tr></table></figure><p><strong>-a</strong> 参数设置修改文件后不需要执行 git add 命令，直接来提交</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git commit -a<br></code></pre></td></tr></table></figure><p><strong>设置提交代码时的用户信息</strong></p><p>开始前我们需要先设置提交的用户信息，包括用户名和邮箱：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;runoob&#x27;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> test@runoob.com<br></code></pre></td></tr></table></figure><p>如果去掉 –global 参数只对当前仓库有效。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用于查看 Git 仓库当前状态，可以查看在你上次提交之后是否有对文件进行再次修改。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>比较文件的不同，即比较文件在暂存区和工作区的差异。</p><p>显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>用于回退版本，可以指定退回某一次提交的版本。</p><blockquote><p>git reset [–soft | –mixed | –hard] [HEAD]</p></blockquote><p><strong>–mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><blockquote><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git reset HEAD^            <span class="hljs-comment"># 回退所有内容到上一个版本  </span><br><span class="hljs-variable">$ </span>git reset HEAD^ hello.php  <span class="hljs-comment"># 回退 hello.php 文件的版本到上一个版本  </span><br><span class="hljs-variable">$ </span>git  reset  <span class="hljs-number">0</span>52e           <span class="hljs-comment"># 回退到指定版本</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>–soft</strong> 参数用于回退到某个版本：</p><blockquote><p>git reset –soft HEAD</p><p>$ git reset –soft HEAD~3   # 回退上上上一个版本 </p></blockquote><p><strong>–hard</strong> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p><blockquote><p>git reset –hard HEAD</p><p>$ git reset –hard HEAD~3  # 回退上上上一个版本<br>$ git reset –hard bae128  # 回退到某个版本回退点之前的所有信息。<br>$ git reset –hard origin&#x2F;master    # 将本地的状态回退到和远程的一样 </p></blockquote><p><strong>HEAD 说明：</strong></p><ul><li>HEAD 表示当前版本</li><li>HEAD^ 上一个版本</li><li>HEAD^^ 上上一个版本</li><li>HEAD^^^ 上上上一个版本</li><li>以此类推…</li></ul><p>可以使用 ～数字表示</p><ul><li>HEAD~0 表示当前版本</li><li>HEAD~1 上一个版本</li><li>HEAD^2 上上一个版本</li><li>HEAD^3 上上上一个版本</li><li>以此类推…</li></ul><p><strong>git reset HEAD 命令用于取消已缓存的内容，即执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</strong></p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>显示可引用的历史版本记录，即显示命令历史</p><p><img src="/2024/07/10/git%E5%91%BD%E4%BB%A4/git学习\2495229-b7cefe27813a4489.webp"></p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><strong>git checkout</strong> 命令用于在不同的分支之间切换、恢复文件、创建新分支等操作。</p><p><strong>切换分支：</strong></p><p>以下命令允许你从当前分支切换到指定的分支 <strong><branch-name></branch-name></strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git checkout <span class="hljs-tag">&lt;<span class="hljs-name">branch-name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如将你的工作目录切换到主分支:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span> <span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p><strong>创建新分支并切换：</strong></p><p>以下命令用于创建一个新分支 <strong><new-branch-name></new-branch-name></strong> 并立即切换到新创建的分支:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git checkout -b &lt;<span class="hljs-built_in">new</span>-branch-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><p>例如创建一个名为 feature-branch 的新分支并切换到它:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git checkout -b <span class="hljs-built_in">feature</span>-branch<br></code></pre></td></tr></table></figure><p><strong>切换到前一个分支：</strong></p><p>以下命令可以让你快速切换回前一个分支，无需记住分支名称:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout -<br></code></pre></td></tr></table></figure><p><strong>检出文件：</strong></p><p>以下命令可以将指定文件 <strong><file></file></strong> 恢复到最新的提交状态，<strong>丢弃所有未提交的更改</strong>，这对于撤销不需要的更改非常有用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- &lt;file&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><em><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</em>*</p></blockquote><p><strong>切换到特定提交：</strong></p><p>你可以使用提交的哈希值 <strong><commit-hash></commit-hash></strong> 来切换到特定的提交状态。这将使你进入”分离头指针”状态，只能查看历史记录，而不能进行分支操作。通常情况下，不建议在分离头指针状态下工作，因为更改可能会丢失。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git checkout &lt;commit-<span class="hljs-built_in">hash</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>切换到标签：</strong></p><p>如果你有一个标签 **<tag-name>**，你可以使用这个命令来切换到该标签所指向的提交状态。</tag-name></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git checkout <span class="hljs-keyword">tags</span>/<span class="hljs-symbol">&lt;tag-name&gt;</span><br></code></pre></td></tr></table></figure><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>git rm 命令用于删除文件。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p><p>git rm 删除文件有以下几种形式：</p><p>1、将文件从暂存区和工作区中删除：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure><p>以下实例从暂存区和工作区中删除 runoob.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> runoob.txt <br></code></pre></td></tr></table></figure><p>2、如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong>。</p><p>强行从暂存区和工作区中删除修改后的 runoob.txt 文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> runoob.txt <br></code></pre></td></tr></table></figure><p>3、想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> --cached &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure><p>以下实例从暂存区中删除 runoob.txt 文件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git rm <span class="hljs-comment">--cached runoob.txt</span><br></code></pre></td></tr></table></figure><p>文件从暂存区域移除，但工作区保留：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> <span class="hljs-literal">--cached</span> README <br><span class="hljs-built_in">rm</span> <span class="hljs-string">&#x27;README&#x27;</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>README<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命令用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p></blockquote><p><strong>实例</strong></p><p>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>相等于：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git push origin <span class="hljs-literal">master</span>:<span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>创建分支命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git <span class="hljs-title function_">branch</span> <span class="hljs-params">(branchname)</span><br></code></pre></td></tr></table></figure><p>列出分支</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><strong>git clone</strong> 是一个用于克隆（clone）远程 Git 仓库到本地的命令。</p><p><strong>git clone</strong> 可以将一个远程 Git 仓库拷贝到本地，让自己能够查看该项目，或者进行修改。</p><p><strong>git clone</strong> 命令，你可以复制远程仓库的所有代码和历史记录，并在本地创建一个与远程仓库相同的仓库副本。</p><p>拷贝项目命令格式如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">[url</span>]<br></code></pre></td></tr></table></figure><p><strong>[url]</strong> 是你要拷贝的项目。</p><p><strong>git clone</strong> 命令会自动将远程仓库的所有分支和历史记录复制到本地，你可以使用其他 Git 命令（如 git checkout、git pull 等）在本地仓库进行操作。</p><p>默认情况下，Git 会按照你提供的 URL 所指向的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 &#x2F; 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><p>例如，以下实例拷贝远程 git 项目，本地项目名为 <strong>another-runoob-name</strong>：</p><blockquote><p><strong>git clone</strong> https:**&#x2F;&#x2F;<strong>github.com</strong>&#x2F;<strong>tianqixin</strong>&#x2F;**runoob-git-test another-runoob-name</p></blockquote><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code>会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。</p><h4 id="stash当前修改"><a href="#stash当前修改" class="headerlink" title="stash当前修改"></a>stash当前修改</h4><p>需要说明一点，stash是本地的，不会通过<code>git push</code>命令上传到git server上。<br>实际应用中推荐给每个stash加一个message，用于记录版本，使用<code>git stash save</code>取代<code>git stash</code>命令。示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ git stash save <span class="hljs-string">&quot;test-cmd-stash&quot;</span><br>Saved working directory <span class="hljs-keyword">and</span> index state <span class="hljs-keyword">On</span> autoswitch: <span class="hljs-keyword">test</span>-cmd-stash<br>HEAD 现在位于 <span class="hljs-number">296</span>e8d4 <span class="hljs-keyword">remove</span> unnecessary postion reset in onResume <span class="hljs-keyword">function</span><br>$ git stash <span class="hljs-keyword">list</span><br>stash@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">On</span> autoswitch: <span class="hljs-keyword">test</span>-cmd-stash<br></code></pre></td></tr></table></figure><h4 id="重新应用缓存的stash"><a href="#重新应用缓存的stash" class="headerlink" title="重新应用缓存的stash"></a>重新应用缓存的stash</h4><p>可以通过<code>git stash pop</code>命令恢复之前缓存的工作目录</p><blockquote><p>这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</p></blockquote><p>你也可以使用<code>git stash apply</code>命令，将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝。</p><blockquote><p>在使用<code>git stash apply</code>命令时可以通过名字指定使用哪个stash，默认使用最近的stash（即stash@{0}）</p></blockquote><h4 id="查看现有stash"><a href="#查看现有stash" class="headerlink" title="查看现有stash"></a>查看现有stash</h4><p>可以使用<code>git stash list</code>命令，一个典型的输出如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ git stash list<br>stash<span class="hljs-variable">@&#123;0&#125;</span>: WIP on master: 049d078 added the <span class="hljs-keyword">index</span> file<br>stash<span class="hljs-variable">@&#123;1&#125;</span>: WIP on master: c264051 Revert <span class="hljs-string">&quot;added file_size&quot;</span><br>stash<span class="hljs-variable">@&#123;2&#125;</span>: WIP on master: 21d80a5 added number to <span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>git cherry-pick 命令用于将指定的提交（commit）应用于其他分支。</p><p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p><p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 git cherry-pick。</p><p>基本语法：</p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git cherry-pick <span class="hljs-tag">&lt;<span class="hljs-name">commitHash</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p>举例来说，代码仓库有 master 和 feature 两个分支。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">a - b - c - d   <span class="hljs-keyword">Master</span><br>        <span class="hljs-title">\</span><br><span class="hljs-title">        e</span> - f - g Feature<br></code></pre></td></tr></table></figure><p>现在将提交 f 应用到 master 分支。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 切换到 master 分支</span><br>$ git checkout <span class="hljs-keyword">master</span><br><br><span class="hljs-title"># Cherry</span> pick 操作<br>$ git cherry-pick f<br></code></pre></td></tr></table></figure><p>上面的操作完成以后，代码库就变成了下面的样子。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">a - b - c - d - f   <span class="hljs-keyword">Master</span><br>        <span class="hljs-title">\</span><br><span class="hljs-title">        e</span> - f - g Feature<br></code></pre></td></tr></table></figure><p>从上面可以看到，master 分支的末尾增加了一个提交 f。</p><p>git cherry-pick 命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ git cherry-pick <span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><p>上面代码表示将feature分支的最近一次提交，转移到当前分支。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实例</p><p>更新操作：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git pull<br><span class="hljs-variable">$ </span>git pull origin<br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><h2 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h2><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><blockquote><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></blockquote><h4 id="新标签"><a href="#新标签" class="headerlink" title="新标签"></a>新标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">&lt;name</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><h4 id="创建带注解的标签"><a href="#创建带注解的标签" class="headerlink" title="创建带注解的标签"></a>创建带注解的标签</h4><p>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><h4 id="查看标签信息"><a href="#查看标签信息" class="headerlink" title="查看标签信息"></a>查看标签信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git show <span class="hljs-tag">&lt;<span class="hljs-name">tagname</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="追加标签"><a href="#追加标签" class="headerlink" title="追加标签"></a>追加标签</h4><p>默认标签是打在最新提交的commit上的</p><p>假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git tag -a v0<span class="hljs-number">.9</span> 85fc7e7<br>$ git <span class="hljs-built_in">log</span> --oneline --decorate --graph<br>*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;<br>|\  <br>| * <span class="hljs-number">7774248</span> (change_site) changed the runoob.php<br>* | c68142b 修改代码<br>|/  <br>* c1501a2 removed test.txt、add runoob.php<br>* 3e92c19 add test.txt<br>* <span class="hljs-number">3b58100</span> (tag: v0<span class="hljs-number">.9</span>) 第一次版本提交<br></code></pre></td></tr></table></figure><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">9</span><br>Deleted <span class="hljs-keyword">tag</span> <span class="hljs-title">&#x27;v0</span>.<span class="hljs-number">9</span>&#x27; (was f52c633)<br></code></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin <span class="hljs-symbol">:refs/tags/v0</span>.<span class="hljs-number">9</span><br><span class="hljs-title class_">To</span> <span class="hljs-symbol">github.com:</span>michaelliao/learngit.git<br> - [deleted]         v0.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h4 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;tagname&gt;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> v1<span class="hljs-number">.0</span><br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v1<span class="hljs-number">.0</span> -&gt; v1<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v0<span class="hljs-number">.9</span> -&gt; v0<span class="hljs-number">.9</span><br></code></pre></td></tr></table></figure><h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>创建分支命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git <span class="hljs-title function_">branch</span> <span class="hljs-params">(branchname)</span><br></code></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">git checkout <span class="hljs-comment">(branchname)</span><br></code></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> <br></code></pre></td></tr></table></figure><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><ol><li><strong>git branch (branchname)</strong></li></ol><blockquote><p>仅创建分支</p></blockquote><ol start="2"><li><strong>git checkout -b (branchname)</strong></li></ol><blockquote><p>创建并切换分支</p></blockquote><ol start="3"><li><strong>git switch -c  (branchname)</strong></li></ol><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">git checkout <span class="hljs-comment">(branch)</span> <br></code></pre></td></tr></table></figure><blockquote><p>$ git branch testing<br>$ git branch</p><ul><li>master<br>testing</li></ul><p>$ git checkout testing</p><p>Switched to branch ‘testing’</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">git <span class="hljs-keyword">switch</span> (branch)<br></code></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">git branch -d (<span class="hljs-name">branchname</span>)<br></code></pre></td></tr></table></figure><p>例如我们要删除 testing 分支：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br>  testing<br><span class="hljs-symbol">$</span> git branch -d testing<br>Deleted branch testing (was <span class="hljs-number">85</span>fc7e7).<br><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span><br></code></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><blockquote><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></blockquote><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p><strong>git remote</strong> 命令用于用于管理 Git 仓库中的远程仓库。</p><p><strong>git remote</strong> 命令提供了一些用于查看、添加、重命名和删除远程仓库的功能。</p><p>以下是 git remote 命令的常见用法：</p><ul><li><code>git remote</code>：列出当前仓库中已配置的远程仓库。</li><li><code>git remote -v</code>：列出当前仓库中已配置的远程仓库，并显示它们的 URL。</li><li><code>git remote add &lt;remote_name&gt; &lt;remote_url&gt;</code>：添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中。</li><li><code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code>：将已配置的远程仓库重命名。</li><li><code>git remote remove &lt;remote_name&gt;</code>：从当前仓库中删除指定的远程仓库。</li><li><code>git remote set-url &lt;remote_name&gt; &lt;new_url&gt;</code>：修改指定远程仓库的 URL。</li><li><code>git remote show &lt;remote_name&gt;</code>：显示指定远程仓库的详细信息，包括 URL 和跟踪分支。</li></ul><p>显示某个远程仓库的信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> remote show<span class="hljs-meta"> [remote]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git remote show https://github.com/tianqixin/runoob-git-test<br>* remote https://github.com/tianqixin/runoob-git-test<br>  Fetch URL: https://github.com/tianqixin/runoob-git-test<br>  Push  URL: https://github.com/tianqixin/runoob-git-test<br>  HEAD branch: <span class="hljs-keyword">master</span><br>  <span class="hljs-title">Local</span> <span class="hljs-keyword">ref</span> configured for &#x27;git push&#x27;:<br>    <span class="hljs-keyword">master</span> <span class="hljs-title">pushes</span> to <span class="hljs-keyword">master</span> <span class="hljs-title">(local</span> out of <span class="hljs-keyword">date</span>)<br></code></pre></td></tr></table></figure><p>添加远程版本库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git remote <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;remote_name&gt;</span> <span class="hljs-symbol">&lt;remote_url&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;remote_name&gt;</code>：要添加的远程仓库的名称。通常，远程仓库的名称为 <code>origin</code>，但你也可以自定义一个名称。</li><li><code>&lt;remote_url&gt;</code>：远程仓库的 URL。它可以是一个指向远程 Git 仓库的 HTTPS、SSH 或 Git 协议链接。</li></ul><p>以下命令将向当前 Git 仓库添加一个名为 origin 的远程仓库，它的 URL 是 <a href="https://github.com/user/repo.git%E3%80%82">https://github.com/user/repo.git。</a></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/user/repo.git</span><br></code></pre></td></tr></table></figure><h2 id="git-查看提交历史"><a href="#git-查看提交历史" class="headerlink" title="git 查看提交历史"></a>git 查看提交历史</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>查看历史提交记录。</p><ul><li><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</p></li><li><p><strong>git log</strong> 命令用于查看 Git 仓库中提交历史记录。</p></li><li><p><strong>git log</strong> 显示了从最新提交到最早提交的所有提交信息，包括提交的哈希值、作者、提交日期和提交消息等。</p></li><li><p><strong>git log</strong> 命令的基本语法：</p></li><li><blockquote><p>git log [选项] [分支名&#x2F;提交哈希]</p></blockquote></li><li><p>常用的选项包括：</p></li><li><ul><li><code>-p</code>：显示提交的补丁（具体更改内容）。</li><li><code>--oneline</code>：以简洁的一行格式显示提交信息。</li><li><code>--graph</code>：以图形化方式显示分支和合并历史。</li><li><code>--decorate</code>：显示分支和标签指向的提交。</li><li><code>--author=&lt;作者&gt;</code>：只显示特定作者的提交。</li><li><code>--since=&lt;时间&gt;</code>：只显示指定时间之后的提交。</li><li><code>--until=&lt;时间&gt;</code>：只显示指定时间之前的提交。</li><li><code>--grep=&lt;模式&gt;</code>：只显示包含指定模式的提交消息。</li><li><code>--no-merges</code>：不显示合并提交。</li><li><code>--stat</code>：显示简略统计信息，包括修改的文件和行数。</li><li><code>--abbrev-commit</code>：使用短提交哈希值。</li><li><code>--pretty=&lt;格式&gt;</code>：使用自定义的提交信息显示格式。</li></ul></li></ul><p>可以用–oneline选项来查看历史记录的简洁版本</p><blockquote><p>git log –oneline</p></blockquote><p>也可以用–reverse参数来逆向显示所有日志</p><blockquote><p>git log –reverse</p></blockquote><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><blockquote><blockquote><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p></blockquote></blockquote><blockquote><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p></blockquote><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><h2 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h2><ol><li><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交的版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。****</p></li><li><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。即，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p></li><li><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p></li><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p></li><li><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p></li><li><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li><li><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><blockquote><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p></blockquote></li><li><p>查看远程库信息，使用<code>git remote -v</code>；</p><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li><li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p></li><li><p>忽略某些文件时，需要编写<code>.gitignore</code>；</p><p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
